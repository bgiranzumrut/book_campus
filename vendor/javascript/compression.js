// compression@1.8.0 downloaded from https://ga.jspm.io/npm:compression@1.8.0/index.js

import*as e from"negotiator";import*as r from"safe-buffer";import*as t from"bytes";import*as n from"compressible";import*as a from"debug";import*as o from"on-headers";import*as s from"vary";import*as i from"zlib";var f=e;try{"default"in e&&(f=e.default)}catch(e){}var d=r;try{"default"in r&&(d=r.default)}catch(e){}var c=t;try{"default"in t&&(c=t.default)}catch(e){}var u=n;try{"default"in n&&(u=n.default)}catch(e){}var l=a;try{"default"in a&&(l=a.default)}catch(e){}var h=o;try{"default"in o&&(h=o.default)}catch(e){}var p=s;try{"default"in s&&(p=s.default)}catch(e){}var m=i;try{"default"in i&&(m=i.default)}catch(e){}var v={};var g=f;var y=d.Buffer;var b=c;var C=u;var H=l("compression");var L=h;var B=p;var z=m;v=compression;v.filter=shouldCompress;var w="createBrotliCompress"in z;var E=/(?:^|,)\s*?no-transform\s*?(?:,|$)/;var S=w?["br","gzip","deflate","identity"]:["gzip","deflate","identity"];var A=w?["br","gzip"]:["gzip"];var D=["gzip","deflate","identity","br"];
/**
 * Compress response data with gzip / deflate.
 *
 * @param {Object} [options]
 * @return {Function} middleware
 * @public
 */function compression(e){var r=e||{};var t={};if(w){Object.assign(t,r.brotli);var n={};n[z.constants.BROTLI_PARAM_QUALITY]=4;t.params=Object.assign(n,t.params)}var a=r.filter||shouldCompress;var o=b.parse(r.threshold);var s=r.enforceEncoding||"identity";o==null&&(o=1024);return function compression(e,n,i){var f=false;var d;var c=[];var u;var l=n.end;var h=n.on;var p=n.write;n.flush=function flush(){u&&u.flush()};n.write=function write(e,r){if(f)return false;headersSent(n)||this.writeHead(this.statusCode);return u?u.write(toBuffer(e,r)):p.call(this,e,r)};n.end=function end(e,r){if(f)return false;if(!headersSent(n)){this.getHeader("Content-Length")||(d=chunkLength(e,r));this.writeHead(this.statusCode)}if(!u)return l.call(this,e,r);f=true;return e?u.end(toBuffer(e,r)):u.end()};n.on=function on(e,r){if(!c||e!=="drain")return h.call(this,e,r);if(u)return u.on(e,r);c.push([e,r]);return this};function nocompress(e){H("no compression: %s",e);addListeners(n,h,c);c=null}L(n,(function onResponseHeaders(){if(a(e,n))if(shouldTransform(e,n)){B(n,"Accept-Encoding");if(Number(n.getHeader("Content-Length"))<o||d<o)nocompress("size below threshold");else{var i=n.getHeader("Content-Encoding")||"identity";if(i==="identity")if(e.method!=="HEAD"){var f=new g(e);var m=f.encoding(S,A);e.headers["accept-encoding"]||D.indexOf(s)===-1||(m=s);if(m&&m!=="identity"){H("%s compression",m);u=m==="gzip"?z.createGzip(r):m==="br"?z.createBrotliCompress(t):z.createDeflate(r);addListeners(u,u.on,c);n.setHeader("Content-Encoding",m);n.removeHeader("Content-Length");u.on("data",(function onStreamData(e){p.call(n,e)===false&&u.pause()}));u.on("end",(function onStreamEnd(){l.call(n)}));h.call(n,"drain",(function onResponseDrain(){u.resume()}))}else nocompress("not acceptable")}else nocompress("HEAD request");else nocompress("already encoded")}}else nocompress("no transform");else nocompress("filtered")}));i()}}function addListeners(e,r,t){for(var n=0;n<t.length;n++)r.apply(e,t[n])}function chunkLength(e,r){return e?y.isBuffer(e)?e.length:y.byteLength(e,r):0}function shouldCompress(e,r){var t=r.getHeader("Content-Type");if(t===void 0||!C(t)){H("%s not compressible",t);return false}return true}function shouldTransform(e,r){var t=r.getHeader("Cache-Control");return!t||!E.test(t)}function toBuffer(e,r){return y.isBuffer(e)?e:y.from(e,r)}
/**
 * Determine if the response headers have been sent.
 *
 * @param {object} res
 * @returns {boolean}
 * @private
 */function headersSent(e){return typeof e.headersSent!=="boolean"?Boolean(e._header):e.headersSent}var T=v;const O=v.filter;export{T as default,O as filter};

